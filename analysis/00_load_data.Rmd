---
title: "Ancestry classifier with principal components"
output: html_notebook
---

0. Pre-processing

Initial: 2,203,614
SNPs: 1,372,115
Common: 129,812
Call rate: 85195
R^2 < 0.1, no callrate filter (bcftools): 66,142

```{bash, eval = F}
INFILE=data/acs_mini_project.vcf.gz ; \
OUTFILE=data/acs_mini_project.2plink

bcftools view -m2 -M2 -v snps ${INFILE}.vcf.gz | bcftools +prune -l 0.1 | bcftools +fill-tags | \ bcftools filter -e 'AF < 0.01' | bcftools filter -e 'F_MISSING >= 0.05' | bgzip -c > \ ${OUTFILE}.vcf.gz

grep "^sample_id\|NA" data/acs_mini_project_labels.txt > data/unlabeled_inds.txt

plink --vcf data/${INFILE}.vcf.gz --make-bed --snps-only --remove \ data/unlabeled_inds.txt --out ${OUTFILE}

# create unlabeled


```

1. Principal component values for the call set.

```{r setup, eval = F}
library(tidyverse)
library(magrittr)
library(DT)
library(adegenet)
library(GGally)
library(RColorBrewer)
library(ggforce)
library(ggnewscale)

labels <- readr::read_delim("../data/acs_mini_project_labels.txt")
labeled_inds <- grep("", labels$ancestry)

fname <- "../data/acs_mini_project.2plink"
dat <- adegenet::read.PLINK(paste0(fname,".raw"))
adegenet::indNames(dat) <- paste0("TGG_", adegenet::indNames(dat))
adegenet::pop(dat) <- labels$ancestry %>% unlist() %>% as.factor()

gt <- as.matrix(dat)

missing_vrnt <- apply(gt_2, 2, function(x) {sum(is.na(x))/ncol(gt) * 100})
missing_smpl <- apply(gt_2, 1, function(x) {sum(is.na(x))/nrow(gt) * 100})

# > miss_smpl_idx
#  TGG_102  TGG_231  TGG_441  TGG_765  TGG_971 TGG_1563 TGG_1850 
#       36       94      169      274      331      534      633 

miss_smpl_idx <- which(missing_smpl > 10)
gt <- gt[-miss_smpl_idx,]
gt <- apply(gt, 2, function(x) {(x - mean(x, na.rm = T)) / sd(x, na.rm = T)})
gt <- t(gt) %>% na.omit() %>% t()

labeled_idx <- which(rownames(gt) %in% unlist(labels[labeled_inds, "sample_id"]))

gt_pca <- prcomp(x = gt[labeled_idx,], center = F, scale. = F)

pca_pve <- data.frame(
  pc = seq(length(gt_pca$sdev)),
  pve = gt_pca$sdev^2 / sum(gt_pca$sdev^2) * 100,
  cumsum_pve = cumsum(gt_pca$sdev^2 / sum(gt_pca$sdev^2) * 100)
  )

ggplot2::ggplot(pca_pve, aes(x = pc, y = pve)) +
  geom_point(stat = "identity") + xlim(0, 30)
ggplot2::ggplot(pca_pve, aes(x = pc, y = cumsum_pve)) +
  geom_point(stat = "identity")
```

Applying predicted model.

```{r}
evec <- predict(gt_pca, gt) %>%
  as.data.frame() %>% 
  tibble::rownames_to_column("sample_id") %>% 
  dplyr::left_join(labels, by = "sample_id") %>% 
  dplyr::relocate(sample_id, ancestry) %>% 
  dplyr::select(sample_id:PC30)

DT::datatable(evec, options = list(scrollX = T))
```

2. Projecting model to samples with missing labels.


```{r model, eval = F}
set.seed(63549)
evec_trn <- evec %>% dplyr::filter(!is.na(ancestry)) %>% tibble::column_to_rownames("sample_id")

idx <- sample(1:nrow(evec_trn), nrow(evec_trn) * 0.8, replace = F)
trn_dat <- evec_trn[idx, c(-1)]
trn_pop <- as.factor(evec_trn[idx, c(1)])
tst_dat <- evec_trn[-idx, c(-1)]
tst_pop <- as.factor(evec_trn[-idx, c(1)])

sqrt_trn_len <- round(sqrt(nrow(trn_dat)))
k_times <- 100

trn_err <- rep(0, k_times)
tst_err <- rep(0, k_times)

for(k in seq(k_times)){
  knn_trn <- class::knn(train = trn_dat, test = trn_dat, cl = trn_pop, k = k, prob = F)
  trn_err[k] = sum(knn_trn != trn_pop)/length(trn_pop)
  knn_tst <- class::knn(train = trn_dat, test = tst_dat, cl = trn_pop, k = k, prob = F)
  tst_err[k] = sum(knn_tst != tst_pop)/length(tst_pop)
  }

knn_df <- data.frame(k = seq(k_times), trn_err = trn_err, tst_err = tst_err)
ggplot2::ggplot(knn_df, ggplot2::aes(x = k)) +
  ggplot2::geom_line(aes(y = trn_err * 100), color = "red") +
  ggplot2::geom_line(aes(y = tst_err * 100), color = "blue") +
  ggplot2::xlab("k") +ggplot2::ylab("Error rate (%)")

```

Choose most accurate.

```{r}
unl_dat <- evec %>% dplyr::filter(is.na(ancestry)) %>% 
  tibble::column_to_rownames("sample_id") %>% 
  dplyr::select(-ancestry)

pred_unl <- class::knn(train = trn_dat, test = unl_dat, cl = trn_pop, k = 50, prob = F)

evec[-labeled_idx,"ancestry"] <- as.character(evec_unl)
evec_df <- evec %>% 
  dplyr::mutate(labeled = as.character(
    sample_id %in% unlist(labels[labeled_inds, "sample_id"]))) %>% 
  dplyr::mutate(labeled = tolower(labeled)) %>% 
  dplyr::relocate(sample_id, ancestry, labeled)
levels(evec_df$labeled) <- c("true", "false")

DT::datatable(evec_df, options = list(scrollX = T))
```

3. Distribution of PC values calc'd by smartpca of all samples, colored by ancestry and shape
by label vs unlabeled

```{r}

pca_df <- evec_df %>% dplyr::select(sample_id:PC3) %>% 
  tidyr::pivot_longer(c(ancestry, labeled), names_to = "grp", values_to = "val")
levels(pca_df$grp) = c("ancestry", "labeled")

plot_legend <- ggplot2::ggplot(subset(pca_df, grp == "ancestry"), aes(x = PC1, y = PC2)) +
  geom_jitter(aes(color = val)) + 
  scale_color_manual(values = brewer.pal(6, "Set2"), name = "ancestry") +
  ggnewscale::new_scale_color() +
  geom_jitter(data = subset(pca_df, grp == "labeled"), aes(color = val)) +
  scale_color_manual(values = brewer.pal(3, "Dark2")[-3], name = "labeled")

pca_plot <- function(pc_a, pc_b, grp_by) {
  mplot <- ggplot2::ggplot(subset(pca_df, grp == grp_by), aes_string(x = pc_a, y = pc_b)) +
    geom_jitter(aes(color = val)) + theme(legend.position = "none") + xlim(-100, 100) +
    ylim(-100, 100)
  return(mplot)
  }

pca_matrix <- ggpairs(evec_df, columns = c("PC1", "PC2", "PC3"),
                    upper = NULL, lower = NULL, diag = NULL, 
                    legend = GGally::grab_legend(plot_legend))
pca_matrix[2,1] <- pca_plot("PC1", "PC2", "ancestry")
pca_matrix[3,1] <- pca_plot("PC1", "PC3", "ancestry")
pca_matrix[3,2] <- pca_plot("PC2", "PC3", "ancestry")
pca_matrix[1,2] <- pca_plot("PC1", "PC2", "labeled")
pca_matrix[1,3] <- pca_plot("PC1", "PC3", "labeled")
pca_matrix[2,3] <- pca_plot("PC2", "PC3", "labeled")

for (i in seq(3)) {
  pca_matrix[i,i] <- ggally_text(
    paste0("PC", i," (", round(pca_pve$pve[i], 3), "%\nof variance\nexplained)"),
    mapping = ggplot2::aes(size = 1), color = I("black")) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          axis.ticks = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank())
  }
pca_matrix
```

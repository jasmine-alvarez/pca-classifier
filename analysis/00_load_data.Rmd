---
title: "Ancestry classifier with principal components"
output: html_notebook
---

0. Pre-processing

Initial: 2,203,614
SNPs: 1,372,115
Common: 129,812
Call rate: 85195
R^2 < 0.1, no callrate filter (bcftools): 66,142

```{bash, eval = F}
INFILE=data/acs_mini_project.vcf.gz ; \
OUTFILE=data/acs_mini_project.2plink

bcftools view -m2 -M2 -v snps ${INFILE}.vcf.gz | bcftools +prune -l 0.1 | bcftools +fill-tags | \ bcftools filter -e 'AF < 0.01' | bcftools filter -e 'F_MISSING >= 0.05' | bgzip -c > \ ${OUTFILE}.vcf.gz

grep "^sample_id\|NA" data/acs_mini_project_labels.txt > data/unlabeled_inds.txt

plink --vcf data/${INFILE}.vcf.gz --make-bed --snps-only --remove \ data/unlabeled_inds.txt --out ${OUTFILE}

# create unlabeled


```

1. Principal component values for the call set.

```{r setup, eval = F}
library(tidyverse)
library(magrittr)
library(DT)
library(adegenet)

labels <- readr::read_delim("../data/acs_mini_project_labels.txt")
labeled_inds <- grep("", labels$ancestry)

fname <- "../data/acs_mini_project.2plink"
dat <- adegenet::read.PLINK(paste0(fname,".raw"))
adegenet::indNames(dat) <- paste0("TGG_", adegenet::indNames(dat))
adegenet::pop(dat) <- labels$ancestry %>% unlist() %>% as.factor()

gt <- as.matrix(dat)
gt <- apply(gt, 2, function(x) {(x - mean(x, na.rm = T)) / sd(x, na.rm = T)})
gt <- log2(gt + 1)
labeled_idx <- which(rownames(gt) %in% unlist(labels[labeled_inds, "sample_id"]))
gt <- t(na.omit(t(gt)))
gt_pca <- prcomp(x = gt[labeled_idx,],center = F, scale. = F)

pca_df <- data.frame(
  pc = seq(length(gt_pca$sdev)),
  pve = gt_pca$sdev^2 / sum(gt_pca$sdev^2) * 100,
  cumsum_pve = cumsum(gt_pca$sdev^2 / sum(gt_pca$sdev^2) * 100)
  )

k_clusters <- pca_df$cumsum_pve[pca_df$cumsum_pve < quantile(pca_df$cumsum_pve, 0.25)] %>% length()

ggplot2::ggplot(pca_df, aes(x = pc, y = cumsum_pve)) +
  geom_point(stat = "identity")

gt_unlabeled<- gt[-labeled_idx,]
prd_model <- predict(gt_pca, gt_unlabeled)

```

```{r}
evec <- predict(gt_pca, gt) %>%
  as.data.frame() %>% 
  tibble::rownames_to_column("sample_id") %>% 
  dplyr::left_join(labels, by = "sample_id") %>% 
  dplyr::relocate(sample_id, ancestry) %>% 
  dplyr::select(sample_id:PC10)

DT::datatable(evec[,seq(12)], options = list(scrollX = T))
```

2. Projecting model to samples with missing labels.

Run smartpca here, not for first:
- top # PCs
- excluded SNPs
- updated samples

final--return table with predicted ancestry of unlabeled

```{r model, eval = F}
set.seed(63549)
# scale(newdata, pca$center, pca$scale) %*% pca$rotation 
evec_trn <- evec %>% dplyr::filter(!is.na(ancestry)) %>% tibble::column_to_rownames("sample_id")

idx <- sample(1:nrow(evec_trn), nrow(evec_trn) * 0.8, replace = F)
trn_dat <- evec_trn[idx, c(-1)]
trn_pop <- as.factor(evec_trn[idx, c(1)])
tst_dat <- evec_trn[-idx, c(-1)]
tst_pop <- as.factor(evec_trn[-idx, c(1)])

k_times <- 60

trn_err <- rep(0, k_times)
tst_err <- rep(0, k_times)

for(k in seq(k_times)){
  knn_trn <- class::knn(train = trn_dat, test = trn_dat, cl = trn_pop, k = k, prob = F)
  trn_err[k] = sum(knn_trn != trn_pop)/length(trn_pop)
  knn_tst <- class::knn(train = trn_dat, test = tst_dat, cl = trn_pop, k = k, prob = F)
  tst_err[k] = sum(knn_tst != tst_pop)/length(tst_pop)
  }

knn_df <- data.frame(k = seq(k_times), trn_err = trn_err, tst_err = tst_err)
ggplot2::ggplot(knn_df, ggplot2::aes(x = k)) +
  ggplot2::geom_line(aes(y = trn_err * 100), color = "red") +
  ggplot2::geom_line(aes(y = tst_err * 100), color = "blue") +
  ggplot2::xlab("k") +ggplot2::ylab("Error rate (%)")

unl_dat <- evec %>% dplyr::filter(is.na(ancestry)) %>% tibble::column_to_rownames("sample_id") %>% 
  dplyr::select(-ancestry)
evec_unl <- class::knn(train = trn_dat, test = unl_dat, cl = trn_pop, k = k, prob = F)

evec[-labeled_idx,"ancestry"] <- as.character(evec_unl)
evec_new <- evec %>% dplyr::filter(is.na(ancestry)) %>% dplyr::mutate(ancestry = evec_unl)

DT::datatable(pred_pops, options = list(scrollX = T))
```

3. Distribution of PC values calc'd by smartpca of all samples, colored by ancestry and shape
by label vs unlabeled

```{r, eval = F}
plot_df <- data.frame(sample_id = rownames(gt_pca$rotation),
                      pc_1 = gt_pca$rotation[,1],
                      pc_2 = gt_pca$rotation[,2]) %>% 
  dplyr::left_join(labels, by = "sample_id")

ggplot2::ggplot(plot_df, ggplot2::aes(x = pc_1, y = pc_2, color = ancestry)) +
  ggplot2::geom_point()
```

4. Supplementary

```{r clustering, eval = F}
dat <- adegenet::read.PLINK(paste0(fname,".raw"))

dat <- dat[labeled_inds]

dat@pop <- as.factor(as.character(unlist(labels[labeled_inds, "ancestry"])))
indNames(dat) <- paste0("TGG_", indNames(dat))

tbl <- as.matrix(dat)
colnames(tbl) <- pedind$snp_id

# chose 200 PCs, 6 clusters
grp <- adegenet::find.clusters(tbl , max.n.clust = 40, center = T, scale = T)
table(adegenet::pop(dat), grp$grp)
ade4::table.value(table(dat@pop,  grp$grp),
                  col.lab = paste0("cluster_", seq(40)))
                  
mydat <- data.frame(n_clusters = seq(60), BIC_score = grp$Kstat)
(BIC_clusters <- ggplot2::ggplot(mydat, ggplot2::aes(x = n_clusters, y = BIC_score)) +
  geom_point())

dapc1 <- adegenet::dapc(tbl, as.factor(grp$grp), center = T, scale = T)
ade4::scatter(dapc1)

contrib <- loadingplot(dapc1$var.contr, axis=2,thres=.07, lab.jitter=1)

compoplot(dapc1, posi="bottomright",
txt.leg=paste("Cluster", 1:6), lab="",
ncol=1, xlab="individuals")

temp <- a.score(dapc1)
optim <- optim.a.score(dapc1)

mtx <-adegenet::tab(dat, NA.method="mean")
colnames(mtx) <- pedind$snp_id
popx <- pop(dat)

xval <- xvalDapc(mtx, popx, n.pca.max = 300, training.set = 0.9,
result = "groupMean", center = TRUE, scale = TRUE,
n.pca = NULL, n.rep = 30, xval.plot = TRUE)

xx <- read.delim("../plink.eigenval", sep = " ", header = F)
yy <- read.delim("../plink.eigenvec", sep = " ", header = F)

# read in the eigenvectors, produced in PLINK
eigenvec <- read.table('../plink.eigenvec', header = FALSE, skip=0, sep = ' ')
eigenvec %<>% dplyr::group_by(V1, V2) %>% 
  dplyr::mutate(sample_id = paste(c(V1, V2), collapse = "_"))
eigenvec %<>% dplyr::left_join(labels, by = "sample_id")

pops <- as.factor(as.character(unlist(labels[labeled_inds, "ancestry"])))
cols <-  RColorBrewer::brewer.pal(6, "Set2")

round(xx[1,1]/sum(xx)*100,digits=2)

scree <- data.frame(PC = seq(20),
                    eig = (round(xx[seq(20),1]/sum(xx)*100,digits=2)))
ggplot2::ggplot(scree, aes(x = PC, y = eig)) + geom_point(stat = "identity")

for (i in seq(20)) {
  message(round(xx[i,1]/sum(xx)*100,digits=2))
}

project.pca <- eigenvec
summary(project.pca)

ggplot2::ggplot(project.pca, aes(x = V3, y = V4, color = ancestry)) + 
  geom_point()
```
